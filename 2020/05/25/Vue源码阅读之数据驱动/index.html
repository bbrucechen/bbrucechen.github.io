<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="小树不倒我不倒">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Vue源码阅读之数据驱动 - undefined
        
    </title>

    <link rel="canonical" href="http://www.brucecave.com/2020/05/25/Vue源码阅读之数据驱动/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Bruce&#39;s cave</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://www.brucecave.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/123123.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Vue" title="Vue">Vue</a>
                        
                    </div>
                    <h1>Vue源码阅读之数据驱动</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Bruce Chen on
                        2020-05-25
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p> 已经用Vue开发过一些项目了，出于兴趣，打算简单研究一下源码，加深自己对Vue这个框架的理解。<br/><br>Vue的第一特点就是数据驱动，数据驱动的意思便是视图层不需要我们手动操控，不需要我们手动调用Web API来对元素进行操作。我们所要做的就是修改数据层中的数据，视图层自动就会发生变化。以下面的代码为例：<br/></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">         &#123;&#123;message&#125;&#125;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     &lt;script&gt;</span><br><span class="line">         new Vue(&#123;</span><br><span class="line">             el:&apos;#app&apos;,</span><br><span class="line">             data:&#123;</span><br><span class="line">                 message:&apos;hello world!&apos;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 打开后会发现页面上显示了’hello world!’,这是Vue最基础的功能，于是我便从这里为切入点开始了Vue源码的探索。由于是初步探索，所以我决定直接按照这个功能的主线走，在执行过程中的一些其他次要的逻辑判断我便暂时。<br/><br> 我们先直接来到路径src/core/instance/index.js的文件。可以看到如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">   // 告诉用户必须New调用</span><br><span class="line">   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">     !(this instanceof Vue)</span><br><span class="line">   ) &#123;</span><br><span class="line">     warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">   &#125;</span><br><span class="line">   // 初始化Vue对象</span><br><span class="line">   this._init(options)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 给Vue的原型添加方法</span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
<p>可以看到,Vue其实就是一个构造函数，必须通过new来调用，当我们new一个Vue实例时，构造函数内部就会判断用户有没有用new调用。然后再执行Vue的内部方法_init来初始化我们传进去的选项。<br/><br>我们知道想构造一个类除了构造函数外还有ES6的Class语法。之所以不用Class是因为Vue有很多方法要构造，不同的方法是放在不同的文件模块里初始化，如果是用Class语法就无法实现这样的模块化构造。<br/><br>那么_init方法是哪里来的呢？其实就是下面的initMIxin方法给Vue定义的。initMixin函数位于src/core/instance/init.js中。其代码如下:<br/></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">export function initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  // 定义初始化函数</span><br><span class="line">  Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    // vm为Vue实例</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // a uid</span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class="line">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // a flag to avoid this being observed</span><br><span class="line">    vm._isVue = true</span><br><span class="line">    // merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果有el属性，则利用mount方法挂载，挂载的目标就是渲染成最终的DOM</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，initMixin函数其实就是在Vue的原型上定义了一个_init方法，这个方法内部对Vue实例进行了一系列的配置，并依次触发了beforeCreate和Created钩子函数，最后执行了$mount方法对el属性指定的元素进行挂载。<br/><br>我们再来具体看看$mount方法的定义。由于这个方法和使用的版本有关，我们这里便以runtime-compiler为准来分析。其$mount方法定义在src/platforms/web/entry-runtime-with-compiler.js中。代码如下:<br/></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 先缓存了runtime-only的$mount方法（定义在runtime/index中）</span><br><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line"></span><br><span class="line">// 再重新定义$mount方法</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  // 限制了不能挂载在html或者body上</span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options = this.$options</span><br><span class="line">  // resolve template/el and convert to render function</span><br><span class="line">  // 如果没有render函数属性，那么就将template或者el属性转为render函数</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template = options.template</span><br><span class="line">    // 如果有指定template属性...</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      // template可以是字符串也可以是元素节点</span><br><span class="line">      // 如果是字符串...</span><br><span class="line">      if (typeof template === &apos;string&apos;) &#123;</span><br><span class="line">        // 可以通过id选择器指定挂载模板</span><br><span class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          /* istanbul ignore if */</span><br><span class="line">          if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              `Template element not found or is empty: $&#123;options.template&#125;`,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果是元素节点，则获取template的内容作为template</span><br><span class="line">      else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125;</span><br><span class="line">      // 都不是则返回错误</span><br><span class="line">      else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">          warn(&apos;invalid template option:&apos; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果没有指定template但指定了el属性，则以el指定的元素的外围元素作为挂载模板</span><br><span class="line">    else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&apos;compile&apos;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&apos;compile end&apos;)</span><br><span class="line">        measure(`vue $&#123;this._name&#125; compile`, &apos;compile&apos;, &apos;compile end&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 最后执行缓存的mount方法。</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在定义compiler版本的mount方法之前，先缓存了runtime的mount方法，因为最终执行的都是这个runtime的mount方法。然后再进行$mount方法的重新定义。在这个方法中，首先限制了挂载元素不能是html或者body。然后进一步判断用户是否有写render属性，如果没有则要获取template并编译成render函数。可以看到template的几种获取规则。如果template写的是id选择器，那么则根据id获取。如果是元素节点，那么就获取其innerHTML作为template。如果没有指定template但指定了el属性，那么则以el属性指定的元素的外部元素作为挂载模板。获取到template之后，便执行compileToFunctions函数将模板编译成render函数。最后执行缓存的原先的mount方法。<br/><br>我们来看看最初的mount方法，其定义在src/platforms/web/runtime/index.js路径中。代码很简单，就是获取el指定元素，然后执行mountComponent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  // 判断el元素是否存在且是否是浏览器环境，是则通过query获取元素否则为undefined</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mountComponent方法的定义是在src/core/instance/lifecycle.js路径下。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You are using the runtime-only build of Vue where the template &apos; +</span><br><span class="line">          &apos;compiler is not available. Either pre-compile the templates into &apos; +</span><br><span class="line">          &apos;render functions, or use the compiler-included build.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Failed to mount component: template or render function not defined.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行beforeMount钩子函数</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      // 通过调用实例的_render方法进行渲染返回VNode</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      // 通过调用实例的_update方法将Vnode挂载到DOM上</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数先是对options中有无render做了判断。然后执行beforeCreate钩子函数。<br>然后便是Vnode的渲染和挂载。我们可以看到是通过执行了_render来进行Vnode的创建，通过_update来执行Vnode在DOM上的挂载。顺着这两条线我们来一一分析。<br/><br>首先是_render方法的定义。其定义位置在src/core/instance/render.js中。相关代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">export function initRender (vm: Component) &#123;</span><br><span class="line">  vm._vnode = null // the root of the child tree</span><br><span class="line">  vm._staticTrees = null // v-once cached trees</span><br><span class="line">  const options = vm.$options</span><br><span class="line">  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree</span><br><span class="line">  const renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line">  // bind the createElement fn to this instance</span><br><span class="line">  // so that we get proper render context inside it.</span><br><span class="line">  // args order: tag, data, children, normalizationType, alwaysNormalize</span><br><span class="line">  // internal version is used by render functions compiled from templates</span><br><span class="line">  vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)</span><br><span class="line">  // normalization is always applied for the public version, used in</span><br><span class="line">  // user-written render functions.</span><br><span class="line">  // 将createElement函数挂载到Vue实例上，应用到手写render函数的情况</span><br><span class="line">  vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)</span><br><span class="line"></span><br><span class="line">  // $attrs &amp; $listeners are exposed for easier HOC creation.</span><br><span class="line">  // they need to be reactive so that HOCs using them are always updated</span><br><span class="line">  const parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  /* istanbul ignore else */</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    defineReactive(vm, &apos;$attrs&apos;, parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm)</span><br><span class="line">    &#125;, true)</span><br><span class="line">    defineReactive(vm, &apos;$listeners&apos;, options._parentListeners || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm)</span><br><span class="line">    &#125;, true)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    defineReactive(vm, &apos;$attrs&apos;, parentData &amp;&amp; parentData.attrs || emptyObject, null, true)</span><br><span class="line">    defineReactive(vm, &apos;$listeners&apos;, options._parentListeners || emptyObject, null, true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function renderMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  // install runtime convenience helpers</span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$nextTick = function (fn: Function) &#123;</span><br><span class="line">    return nextTick(fn, this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._render = function (): VNode &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    const &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">        _parentVnode.data.scopedSlots,</span><br><span class="line">        vm.$slots,</span><br><span class="line">        vm.$scopedSlots</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set parent vnode. this allows render functions to have access</span><br><span class="line">    // to the data on the placeholder node.</span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    // render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      // There&apos;s no need to maintain a stack becaues all render fns are called</span><br><span class="line">      // separately from one another. Nested component&apos;s render fns are called</span><br><span class="line">      // when parent component is patched.</span><br><span class="line">      currentRenderingInstance = vm</span><br><span class="line">      // 从这里可以看出render函数是通过调用createElement来创建Vnode的</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      handleError(e, vm, `render`)</span><br><span class="line">      // return error render result,</span><br><span class="line">      // or previous vnode to prevent render error causing blank component</span><br><span class="line">      /* istanbul ignore else */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, `renderError`)</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      currentRenderingInstance = null</span><br><span class="line">    &#125;</span><br><span class="line">    // if the returned array contains only a single node, allow it</span><br><span class="line">    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123;</span><br><span class="line">      vnode = vnode[0]</span><br><span class="line">    &#125;</span><br><span class="line">    // return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Multiple root nodes returned from render function. Render function &apos; +</span><br><span class="line">          &apos;should return a single root node.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    // set parent</span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Vue实例的_render方法是在renderMixins中定义，这个方法最终是通过执行createElements方法来创建Vnode的。createElement方法定义在src/core/vdom/create-element.js中。其主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">export function createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag: any,</span><br><span class="line">  data: any,</span><br><span class="line">  children: any,</span><br><span class="line">  normalizationType: any,</span><br><span class="line">  alwaysNormalize: boolean</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  return _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function _createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">  data?: VNodeData,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +</span><br><span class="line">      &apos;Always create fresh vnode data objects in each render!&apos;,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  // object syntax in v-bind</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  if (!tag) &#123;</span><br><span class="line">    // in case of component :is set to falsy value</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  // warn against non-primitive key</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (!__WEEX__ || !(&apos;@binding&apos; in data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &apos;Avoid using non-primitive value as key, &apos; +</span><br><span class="line">        &apos;use string/number value instead.&apos;,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // support single function children as default scoped slot</span><br><span class="line">  if (Array.isArray(children) &amp;&amp;</span><br><span class="line">    typeof children[0] === &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; default: children[0] &#125;</span><br><span class="line">    children.length = 0</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果render函数是手写的。或者编译v-for/slot时会产生数组嵌套。就需要调用这个</span><br><span class="line">  if (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  // 对数组进行规范化，如果render函数是编译时生成的，则宿友children都是VNode形式，只要将其扁平化即可</span><br><span class="line">  else if (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  // 正式创建VNode实例</span><br><span class="line">  let vnode, ns</span><br><span class="line">  if (typeof tag === &apos;string&apos;) &#123;</span><br><span class="line">    let Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    // 如果是内置节点，则直接创建普通的一个VNode</span><br><span class="line">    if (config.isReservedTag(tag)) &#123;</span><br><span class="line">      // platform built-in elements</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果是一个组件，则调用createComponents</span><br><span class="line">    else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123;</span><br><span class="line">      // component</span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则创建一个未知的tag的VNode</span><br><span class="line">    else &#123;</span><br><span class="line">      // unknown or unlisted namespaced elements</span><br><span class="line">      // check at runtime because it may get assigned a namespace when its</span><br><span class="line">      // parent normalizes children</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // direct component options / constructor</span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  if (Array.isArray(vnode)) &#123;</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else if (isDef(vnode)) &#123;</span><br><span class="line">    if (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    if (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终执行的是_createElement函数。这个函数对数据进行了一系列判断。并根据编译模式选择不同的策略处理当前指定节点的子节点。如果render函数是用户手写的，那么就要调用normalizeChildren对嵌套的子节点进行Vnode的转化。如果render函数是编译时生成的，那么说明所有节点都已经是vnode形式，只需要扁平化即可。最后通过Vnode构造函数创建并返回Vnode节点。<br/><br>到这里为止，我们便知道了VNode的生成过程，接下来便是要将VNode渲染成真正的DOM元素。回到mountComponent函数中，我们可以看到这一步是通过Vue实例的内部方法_patch来实现的。该方法定义在src/core/instance/lifecycle.js中。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export function lifecycleMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    const prevEl = vm.$el</span><br><span class="line">    const prevVnode = vm._vnode</span><br><span class="line">    const restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    // Vue.prototype.__patch__ is injected in entry points</span><br><span class="line">    // based on the rendering backend used.</span><br><span class="line">    if (!prevVnode) &#123;</span><br><span class="line">      // initial render</span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // updates</span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    // update __vue__ reference</span><br><span class="line">    if (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = null</span><br><span class="line">    &#125;</span><br><span class="line">    if (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // if parent is an HOC, update its $el as well</span><br><span class="line">    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    // updated hook is called by the scheduler to ensure that children are</span><br><span class="line">    // updated in a parent&apos;s updated hook.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中传入的第一个参数是创建好的VNode，可以看出其最终是执行了Vue实例的<strong>patch</strong>方法。该方法定义在src/platforms/web/runtime/index.js中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure>
<p>如果实在浏览器中，则返回patch函数。patch函数定义在src/platforms/web/runtime/patch.js中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>
<p>其中nodeOpe是传入的DOM操作方法序列。因为不同平台的nodeOps和modules不同，所以这个patch的具体构造要放在platforms文件下。此外还通过柯里化的办法，利用createPatchFunction的方法来提前固定差异化的参数，这样就不用每次调用path方法时都要传递nodeOps和modules参数。createFunction的定义如下：<br/></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">export function createPatchFunction (backend) &#123;</span><br><span class="line">  let i, j</span><br><span class="line">  const cbs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const &#123; modules, nodeOps &#125; = backend</span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    for (j = 0; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      if (isDef(modules[j][hooks[i]])) &#123;</span><br><span class="line">        cbs[hooks[i]].push(modules[j][hooks[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  </span><br><span class="line">  return function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    // oldVnode是根据el元素获取的DOM元素，vnode是当前实例转化后的VNode</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let isInitialPatch = false</span><br><span class="line">    const insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      // empty mount (likely as component), create new root element</span><br><span class="line">      isInitialPatch = true</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const isRealElement = isDef(oldVnode.nodeType) // 结果为true</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        // patch existing root node</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          // mounting to a real element</span><br><span class="line">          // check if this is server-rendered content and if we can perform</span><br><span class="line">          // a successful hydration.</span><br><span class="line">          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &apos;The client-side rendered virtual DOM tree is not matching &apos; +</span><br><span class="line">                &apos;server-rendered content. This is likely caused by incorrect &apos; +</span><br><span class="line">                &apos;HTML markup, for example nesting block-level elements inside &apos; +</span><br><span class="line">                &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; +</span><br><span class="line">                &apos;full client-side render.&apos;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // either not server-rendered, or hydration failed.</span><br><span class="line">          // create an empty node and replace it</span><br><span class="line"></span><br><span class="line">          // 把el元素转为Vnode</span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // replacing existing element</span><br><span class="line">        const oldElm = oldVnode.elm</span><br><span class="line">        const parentElm = nodeOps.parentNode(oldElm)// 即body元素</span><br><span class="line"></span><br><span class="line">        // create new node</span><br><span class="line">        // 调用createElm根据Vnode创建元素</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          // extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          // leaving transition. Only happens when combining transition +</span><br><span class="line">          // keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor = vnode.parent</span><br><span class="line">          const patchable = isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i = 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              // #6513</span><br><span class="line">              // invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              // e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert = ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                // start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i = 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // destroy old node</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其本质就是返回了一个patch函数，oldVnode是根据el元素获取的DOM元素，vnode是当前实例转化后的VNode。patch内部调用createElm根据Vnode创建元素。createElm函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">function createElm (</span><br><span class="line">  vnode, // 要创建的元素的vnode</span><br><span class="line">  insertedVnodeQueue,</span><br><span class="line">  parentElm, // 要创建的元素的父元素</span><br><span class="line">  refElm,</span><br><span class="line">  nested,</span><br><span class="line">  ownerArray,</span><br><span class="line">  index</span><br><span class="line">) &#123;</span><br><span class="line">  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    // This vnode was used in a previous render!</span><br><span class="line">    // now it&apos;s used as a new node, overwriting its elm would cause</span><br><span class="line">    // potential patch errors down the road when it&apos;s used as an insertion</span><br><span class="line">    // reference node. Instead, we clone the node on-demand before creating</span><br><span class="line">    // associated DOM element for it.</span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vnode.isRootInsert = !nested // for transition enter check</span><br><span class="line">  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const data = vnode.data</span><br><span class="line">  const children = vnode.children</span><br><span class="line">  const tag = vnode.tag</span><br><span class="line">  // 查看tag属性是否存在</span><br><span class="line">  if (isDef(tag)) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      if (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      if (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Unknown custom element: &lt;&apos; + tag + &apos;&gt; - did you &apos; +</span><br><span class="line">          &apos;register the component correctly? For recursive components, &apos; +</span><br><span class="line">          &apos;make sure to provide the &quot;name&quot; option.&apos;,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用平台DOM的操作去创建一个第一个参数vnode为准的占位符元素</span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (__WEEX__) &#123;</span><br><span class="line">      // in Weex, the default insertion order is parent-first.</span><br><span class="line">      // List items can be optimized to use children-first insertion</span><br><span class="line">      // with append=&quot;tree&quot;.</span><br><span class="line">      const appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      if (!appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      if (appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 然后创建子元素，把当前创建的元素作为父元素传入</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      // 然后执行所有create钩子函数</span><br><span class="line">      if (isDef(data)) &#123;</span><br><span class="line">        // 执行所有created钩子函数</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">    // 最后进行插入元素</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用平台DOM的操作（nodeOps）去创建一个第一个参数vnode为准的占位符元素。然后便是通过createChildren函数创建子元素。createChildren的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createChildren (vnode, children, insertedVnodeQueue) &#123; // vnode是父元素 children是创建的子元素数组</span><br><span class="line">   if (Array.isArray(children)) &#123;</span><br><span class="line">     if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">       checkDuplicateKeys(children)</span><br><span class="line">     &#125;</span><br><span class="line">     for (let i = 0; i &lt; children.length; ++i) &#123;</span><br><span class="line">       // 遍历递归调用createElm生成子元素</span><br><span class="line">       createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else if (isPrimitive(vnode.text)) &#123;</span><br><span class="line">     nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>createChildren其实很简单，便是遍历children并且递归调用createElm生成即可。如果是文字节点则直接append到父节点之后。全部元素创建完之后，便通过insert方法进行插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">insert(parentElm, vnode.elm, refElm)</span><br><span class="line"></span><br><span class="line">function insert (parent, elm, ref) &#123;</span><br><span class="line">    // parent代表父元素 ele代表要插入的元素</span><br><span class="line">    if (isDef(parent)) &#123;</span><br><span class="line">      if (isDef(ref)) &#123;</span><br><span class="line">        // 调用原生API进行元素插入</span><br><span class="line">        if (nodeOps.parentNode(ref) === parent) &#123;</span><br><span class="line">          nodeOps.insertBefore(parent, elm, ref)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        nodeOps.appendChild(parent, elm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这就是最终调用原生API的地方。所以Vue实例从创建到挂载的整个过程如下图：<br/><br><img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="image"></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2020/05/31/Vue源码之响应式/" data-toggle="tooltip" data-placement="top" title="Vue源码之响应式">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2020/05/22/实现一个简单的将RGB转为十六进制的函数/" data-toggle="tooltip" data-placement="top" title="实现一个简单的将RGB转为十六进制的函数">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/bbrucechen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Bruce&#39;s cave 2020 
                    <br>
                    Theme by <a href="http://huangxuan.me" target="_blank" rel="noopener">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks" target="_blank" rel="noopener">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://www.brucecave.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://www.brucecave.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
